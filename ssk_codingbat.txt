1. sleepIN

public boolean sleepIn(boolean weekday, boolean vacation) {
  if(vacation || !weekday){
    return true;
  }
  return false;
}

Solution:
public boolean sleepIn(boolean weekday, boolean vacation) {
  if (!weekday || vacation) {
    return true;
  }
  
  return false;
  
  // Solution notes: better to write "vacation" than "vacation == true"
  // though they mean exactly the same thing.
  // Likewise "!weekday" is better than "weekday == false".
  // This all can be shortened to: return (!weekday || vacation);
  // Here we just put the return-false last, or could use an if/else.
}


2. monkeyTrouble

public boolean monkeyTrouble(boolean aSmile, boolean bSmile) {
  if(aSmile ^ !bSmile){
    return true;
  }
  return false;
}


Solution:
public boolean monkeyTrouble(boolean aSmile, boolean bSmile) {
  if (aSmile && bSmile) {
    return true;
  }
  if (!aSmile && !bSmile) {
    return true;
  }
  return false;
  // The above can be shortened to:
  //   return ((aSmile && bSmile) || (!aSmile && !bSmile));
  // Or this very short version (think about how this is the same as the above)
  //   return (aSmile == bSmile);
}


3. sumDouble
public int sumDouble(int a, int b) {
  if(a==b){
    return a*2 + b*2;
  }
  return a+b;
}


Solution:
public int sumDouble(int a, int b) {
  // Store the sum in a local variable
  int sum = a + b;
  
  // Double it if a and b are the same
  if (a == b) {
    sum = sum * 2;
  }
  
  return sum;
}


4. diff21

public int diff21(int n) {
  
  int diff= 21-n;
  if (diff<=0){
    return -(diff*2);
  
  }
  else return diff;
    
  
}


Solution:
public int diff21(int n) {
  if (n <= 21) {
    return 21 - n;
  } else {
    return (n - 21) * 2;
  }
}



5. parrotTrouble

public boolean parrotTrouble(boolean talking, int hour) {
  return (talking&&(hour<7||hour>20));
  
}


Solution:
public boolean parrotTrouble(boolean talking, int hour) {
  return (talking && (hour < 7 || hour > 20));
  // Need extra parenthesis around the || clause
  // since && binds more tightly than ||
  // && is like arithmetic *, || is like arithmetic +
}


6. makes10

public boolean makes10(int a, int b) {
   return (a == 10 || b == 10 || a+b == 10);
}


Solution:
public boolean makes10(int a, int b) {
  return (a == 10 || b == 10 || a+b == 10);
}


7. nearHundred

public boolean nearHundred(int n) {
  return((n>=90&&n<=110)||(n>=190&&n<=210));
}


Solution:
public boolean nearHundred(int n) {
  return ((Math.abs(100 - n) <= 10) ||
    (Math.abs(200 - n) <= 10));
}


8. posNeg

Solution:
public boolean nearHundred(int n) {
  return ((Math.abs(100 - n) <= 10) ||
    (Math.abs(200 - n) <= 10));
}


Solution:
public boolean posNeg(int a, int b, boolean negative) {
  if (negative) {
    return (a < 0 && b < 0);
  }
  else {
    return ((a < 0 && b > 0) || (a > 0 && b < 0));
  }
}


9. notString

public String notString(String str) {
  
  if(str.length()<=2)
  {
    return "not "+ str;
  }
  
  else {
    String str1= str.substring(0,3);
    if(str1.equals("not"))
  {
    return str;
  }
  else return "not " + str ;
  }
}


Solution:
public String notString(String str) {
  if (str.length() >= 3 && str.substring(0, 3).equals("not")) {
    return str;
  }
  
  return "not " + str;
}


10. missingChar

public String missingChar(String str, int n) {
  
 // int len = str.length();
  return (str.substring(0,n) + str.substring(n+1));
}



Solution:
public String missingChar(String str, int n) {
  String front = str.substring(0, n);
  
  // Start this substring at n+1 to omit the char.
  // Can also be shortened to just str.substring(n+1)
  // which goes through the end of the string.
  String back = str.substring(n+1, str.length());
  
  return front + back;
}


11. frontBack

public String frontBack(String str) {
  int len= str.length();
  if(len<=1)
  {
    return str;
  }
  
  return str.substring(len-1) + str.substring(1,len-1) + str.substring(0,1);

}


Solution:
public String frontBack(String str) {
  if (str.length() <= 1) return str;
  
  String mid = str.substring(1, str.length()-1);
  
  // last + mid + first
  return str.charAt(str.length()-1) + mid + str.charAt(0);
}


12. front3

public String front3(String str) {
  if(str.length() < 3)
  {
    return str + str + str;
  }
  return str.substring(0,3) + str.substring(0,3) + str.substring(0,3);
}



Solution:
public String front3(String str) {
  String front;
  
  if (str.length() >= 3) {
    front = str.substring(0, 3);
  }
  else {
    front = str;
  }

  return front + front + front;
}


13. backAround

public String backAround(String str) {
  return str.charAt(str.length()-1) + str + str.charAt(str.length()-1);
}



Solution:
public String backAround(String str) {
  // Get the last char
  String last = str.substring(str.length() - 1);
  return last + str + last;
}


14. or35

public boolean or35(int n) {
  if((n % 3) == 0 || (n % 5) == 0)
  {
    return true;
  }
  return false;
}


Solution:
public boolean or35(int n) {
  return (n % 3 == 0) || (n % 5 == 0);
}


15. front22

public String front22(String str) {
  
  
  if(str.length()<2)
  {
    return str + str + str;
  }
 else 
 {
   String front = str.substring(0,2);
   return front + str + front;
 }
  
  return str;
  
  
}



Solution:
public String front22(String str) {
  // First figure the number of chars to take
  int take = 2;
  if (take > str.length()) {
    take = str.length();
  }
  
  String front = str.substring(0, take);
  return front + str + front;
}



16. start Hi:

public boolean startHi(String str) 
{
if(str.length()>1)
  
{return (str.substring(0,2).equals("hi"));}
  
else return false;

}

16. 
public boolean startHi(String str) {
  // First test if the string is not at least length 2
  // (so the substring() below does not go past the end).
  if (str.length() < 2) return false;
  
  // Pull out the string of the first two chars
  String firstTwo = str.substring(0, 2);
  
  // Test if it is equal to "hi"
  if (firstTwo.equals("hi")) {
    return true;
  } else {
    return false;
  }
  // This last part can be shortened to: return(firstTwo.equals("hi"));
}

=================================================================================================


17. icyHot

public boolean icyHot(int temp1, int temp2)
{

return ((temp1>100 && temp2<0) || (temp1<0 && temp2>100));

}


18. in1020

public boolean in1020(int a, int b)
{

return ((a>=10 && a<=20) || (b>=10 && b<=20));

}

19. hasTeen

public boolean hasTeen(int a, int b, int c)
{

return ((a>=13 && a<=19) || (b>=13 && b<=19) || (c>=13 && c<=19));

}



20. loneTeen
public boolean loneTeen(int a, int b) 

{

return (((a>=13 && a<=19) && (b>19 || b<13)) || ((b>=13 && b<=19)&& (a>19 || a<13)));

}


Solution:
public boolean loneTeen(int a, int b) {
  // Store teen-ness in boolean local vars first. Boolean local
  // vars like this are a little rare, but here they work great.
  boolean aTeen = (a >= 13 && a <= 19);
  boolean bTeen = (b >= 13 && b <= 19);
  
  return (aTeen && !bTeen) || (!aTeen && bTeen);
  // Translation: one or the other, but not both.
  // Alternately could use the Java xor operator, but it's obscure.
}



21. delDel

public String delDel(String str)
{

if (str.length()<4) return str;

else if(str.substring(1,4).equals("del"))
{

return str.charAt(0) + str.substring(4,str.length());
 
}
 
else return str;

}

Solution:
public String delDel(String str) {
  if (str.length()>=4 && str.substring(1, 4).equals("del")) {
    // First char + rest of string starting at 4
    return str.substring(0, 1) + str.substring(4);
  }
  // Otherwise return the original string.
  return str;
}



22. mixStart

public boolean mixStart(String str) 
{

if(str.length()>2)
 
return (str.substring(1,3).equals("ix"));

else return false;

}


Solution:
public boolean mixStart(String str) {
  // Check if string is too small
  // (so substring() below does not go off the end)
  if (str.length() < 3) return false;
  
  // Pull out length 2 string for the "ix" part
  // (i.e. substring starting at index 1 and stopping just before 3).
  String two = str.substring(1, 3);
  
  if (two.equals("ix")) {
    return true;
  } else {
    return false;
  }
  // This last part can be shortened to just:
  // return(two.equals("ix"));
}




23.startOZ

public String startOz(String str) {
  
  if(str.length()>0){
    
  if ((str.charAt(0)=='o' && (str.charAt(1)=='z')))
  return str.substring(0,2);
  else if ((str.charAt(0)=='o' && !(str.charAt(1)=='z')))
  return str.substring(0,1);
  else if ((!(str.charAt(0)=='o') && (str.charAt(1)=='z')))
  return str.substring(1,2);
  else return "";
  }
  else return "";
}



Solution:
public String startOz(String str) {
  String result = "";
  
  if (str.length() >= 1 && str.charAt(0)=='o') {
    result = result + str.charAt(0);
  }
  
  if (str.length() >= 2 && str.charAt(1)=='z') {
    result = result + str.charAt(1);
  }
  
  return result;
}




24. intMax

public int intMax(int a, int b, int c) {
  if(a>b)
  {
    if(a>c)
    return a;
  }
  else if(b>c)
  {
    return b;
  }
  return c;
}


Solution:
public int intMax(int a, int b, int c) {
  int max;
  
  // First check between a and b
  if (a > b) {
    max = a;
  } else {
    max = b;
  }
  
  // Now check between max and c
  if (c > max) {
    max = c;
  }
  
  return max;
  
  // Could use the built in Math.max(x, y) function which selects the larger
  // of two values.
}



close10:

public int close10(int a, int b) {
  if(Math.abs(a-10) > Math.abs(b-10)) 
  {
    return b;
  }
  else if (Math.abs(a-10) < Math.abs(b-10)) 
  { 
    return a;
    
  }
  return 0;
}


public int close10(int a, int b) {
  int aDiff = Math.abs(a - 10);
  int bDiff = Math.abs(b - 10);
  
  if (aDiff < bDiff) {
    return a;
  }
  if (bDiff < aDiff) {
    return b;
  }
  return 0;  // i.e. aDiff == bDiff
  
  // Solution notes: aDiff/bDiff local vars clean the code up a bit.
  // Could have "else" before the second if and the return 0.
}



